; da65 V2.19 - Git cf0688fc5
; Created:    2025-05-05 12:22:48
; Input file: kk9.bin
; Page:       1


            .setcpu "6502"

            .include "symbols.inc"
            .include "codos.inc"

            .segment "overlays"

            .byte   $09             ; Overlay number

GLOCLINELEN = $2C                   ; Length of GETLOC info lines    

; GETLOC Command
;
; DESCRIPTION:  Display the Entry point, Starting load address, and Final load
;               address for a file previously generated by the SAVE command. 
;
; SYNTAX:       GETLOC <file>[:<drive>]
;
; ARGUMENTS:    <file> = file name
;               <drive> = disk drive number, 0 to 3. Defaults to current default
;               drive, usually 0
;
.proc GETLOC
            jsr     GETFILNDRV      ; Get file and drive from the command line
            jsr     FOPEN0          ; Assigns channel 0 to file
            ldx     #$00            ; Load "saved file" header from channel 0
            jsr     LD58HDR         ; at current file position
            bcc     CONT            ; If OK, continue
ERROR:      jsr     ERROR13         ; Not a loadable ("SAVEd") file
            ; Not reached

                                    ; Get file overlay
CONT:       lda     SAVEDHDR+SHDR::OVLAY
            bne     ERROR           ; Must be 0
            ldy     #GLOCLINELEN    ; Clear output buffer with spaces
            lda     #' '            ;
CLRB:       sta     (OUTBUFP),y     ;
            dey                     ;
            bpl     CLRB            ;
            ldx     #$00            ; Copy file name to output buffer
            ldy     #$00            ;
                                    ; Copy one char
CPCH:       lda     DIRENT+DIRE::FNAM,x
            sta     (OUTBUFP),y     ;
            inx                     ; Advance in both file name and buffer
            iny                     ;
            cmp     #'.'            ; Last was extension delimiter?
            bne     CPCH            ; No, copy next char
                                    ; Copy extension
            lda     DIRENT+DIRE::FNAM,x
            sta     (OUTBUFP),y     ;
            iny                     ; Leave an space
            iny                     ; Advance one pos
            lda     #'='            ; Copy the '='
            sta     (OUTBUFP),y     ;
            iny                     ; Advance to next pos
            ldx     #$05            ; Copy pointers to page 0 (entry will be at
                                    ; P0SCRATCH, load address at MEMBUFF and size
CPPT:       lda     SAVEDHDR+SHDR::ENTRY,x
            sta     P0SCRATCH,x     ; at MEMCOUNT)
            dex                     ;
            bpl     CPPT            ;
            jsr     HEXENCOD0       ; Convert entry to ASCII HEX into (OUTBUFP),y
            iny                     ; Leave three spaces
            iny                     ;
            iny                     ;
            sty     LOADPOS         ; Save pos of load address for next lines
PRLOAD:     ldx     #_MEMBUFF       ; Convert load address to ASCII HEX
            jsr     HEXENCOD        ;
            iny                     ; Leave two spaces
            iny                     ;
.ifdef ::mtu
                                    ; Get memory bank
            lda     SAVEDHDR+SHDR::MEMBK
            beq     PRSZ            ; If bank 0, skip to print size
            dey                     ; Go back just after the address
            dey                     ;
            lda     #':'            ; Print bank delimiter
            sta     (OUTBUFP),y     ;
            iny                     ; Advance one pos
                                    ; Get bank number
            lda     SAVEDHDR+SHDR::MEMBK
            clc                     ; Convert to ascii
            adc     #'0'            ;
            sta     (OUTBUFP),y     ; Print it
            iny                     ; And advance one pos
.endif
PRSZ:       iny                     ; Leave one space
            ldx     MEMBUFF         ; Calculate final load address
            bne     SKIP            ; decrementing start load address
            dec     MEMBUFF+1       ;
SKIP:       dex                     ;
            txa                     ;
            clc                     ; And adding block size
            adc     MEMCOUNT        ;
            sta     P0SCRATCH       ;
            lda     MEMBUFF+1       ;
            adc     MEMCOUNT+1      ;
            sta     P0SCRATCH+1     ;
            jsr     HEXENCOD0       ; Print it
                                    ; Calculate file pos for next block
            lda     CURFINFO+FINFO::FPOS
            clc                     ; adding size to current position
            adc     MEMCOUNT        ;
            sta     FILEPOS         ; and store into FILEPOS
            lda     CURFINFO+FINFO::FPOS+1
            adc     MEMCOUNT+1      ;
            sta     FILEPOS+1       ;
            lda     CURFINFO+FINFO::FPOS+2
            adc     #$00            ;
            sta     FILEPOS+2       ;
            lda     FILEPOS         ; Now adjusts FILEPOS to point at the
            sec                     ; beginning of the saved file header
            sbc     #FHDRLEN        ; for the next block
            sta     FILEPOS         ;
            lda     FILEPOS+1       ;
            sbc     #$00            ;
            sta     FILEPOS+1       ;
            lda     FILEPOS+2       ;
            sbc     #$00            ;
            sta     FILEPOS+2       ;

            sty     OUTBUFLEN       ; Save output buffer length
            ldx     #$00            ; Load sector for current file position
            jsr     FSEEK           ; of channel 0
            ldy     OUTBUFLEN       ; Recover output buffer length
            jsr     POUTBUFFCR02    ; Output Y chars from (OUTBUFP) to console + CR
            ldx     #$00            ; Load next saved file header from channel 0
            jsr     LD58HDR         ;
            bcc     NXBLK           ; OK, go process next block
NOMORE:     jsr     FREECH0         ; No more blocks. Free channel
            ldy     CMDLIDX         ; Recover command line index
            jsr     GETNEXTNB       ; Get next non-blank from command line
            beq     RETURN          ; No more, we're finished
            jmp     GETLOC          ; Go process next file

                                     ; If overlay is not 0
NXBLK:      lda     SAVEDHDR+SHDR::OVLAY
            bne     NOMORE          ; Then no more blocks
            ldy     #GLOCLINELEN-5  ; Clear output buffer. Last 5 bytes will
            lda     #' '            ; be overwritten anyways, so save a few
CLRB2:      sta     (OUTBUFP),y     ; cycles here
            dey                     ;
            bpl     CLRB2           ;
            ldx     #$03            ; Copies load address and size
                                    ; for next block
CPPT2:      lda     SAVEDHDR+SHDR::LOAD,x
            sta     MEMBUFF,x       ;
            dex                     ;
            bpl     CPPT2           ;
            ldy     LOADPOS         ; Get pos of load address for next lines
            jmp     PRLOAD          ; And go print load address

RETURN:     rts
.endproc

LOADPOS:    .byte   $01             ; Pos of load address for 2nd and following lines
OUTBUFLEN:  .byte   $01             ; Length of output buffer to print

.ifdef mtu
            ; This block is just junk that was in the buffer when
            ; writing it to disk. I leave it to facilitate checksum
            ; comparisons with the original
            ;
            .byte        $30, $91, $CD, $4C, $A7, $FE, $60
            .byte   $20, $68, $D9, $A2, $01, $4C, $94, $F5
            .byte   $D7, $FE, $00, $FE, $60, $00, $00, $1E
.endif
            .end
